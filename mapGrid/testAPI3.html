<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <title>Tests de l'api</title>
</head>
<body onload="initialize()">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div class="row">
					<div class="col-lg-6">
						<div id="map" style="width: 550px; height: 480px;"></div>
						<div class="row">
							<div class="col-lg-12">
								<input id="address" type="text" value="Tabuant" title="address">
								<input type="button" value="Créer quadrillage" onclick="codeAddress()">
								<input type="button" value="Afficher JSON" onclick="printJSON()">
								<input type="button" value="Enregistrer JSON" onclick="download()">
							</div>
							<div class="col-lg-12">
								<h3>Importer un fichier JSON (après quadrillage)</h3>
								<input id="file" type="file" />
							</div>
						</div>
					</div>
					<div class="col-lg-6">
						<div class="row">
							<div class="col-lg-6">
								<h3>Création de zone</h3>
								<form>
									<p>
										<label for="nameZone">Nom de la zone</label>
										<input type="text" name="nameZone" id="nameZone">
									</p>
									<p>
										<label for="descriptionZone">Description de la zone</label>
										<input type="text" name="descriptionZone" id="descriptionZone">
									</p>
									<input type="button" id="createZoneButton" value="Créer zone" onclick="createZone()" class="btn btn-primary">
								</form>
							</div>
							<div class="col-lg-6">
								<h3>Ajout d'une balise</h3>
								<form>
									<p>
										<label for="difficulty">Difficulté (1 à 5)</label>
										<input type="range" name="difficulty" id="difficulty" min="1" max="5" required>
									</p>
									<p>
										<label for="themeBeacon">Theme</label>
										<select name="themeBeacon" id="themeBeacon">
											<option value="SP" selected>Sport</option>
											<option value="CUL">Culture</option>
											<option value="BE">Bord de l'eau</option>
											<option value="XX">Autre</option>
										</select>
									</p>
									<p>
										<label for="nameBeacon">Nom</label>
										<input type="text" name="nameBeacon" id="nameBeacon" required>
									</p>
									<p>
										<label for="descriptionBeacon">Description</label>
										<input type="text" name="descriptionBeacon" id="descriptionBeacon" required>
									</p>
									<p>
										<label for="descriptionMonument">Description du monument associé</label>
										<input type="text" name="descriptionMonument" id="descriptionMonument" required>
									</p>
									<p>
										<label for="hashToken">Hash du token</label>
										<input type="text" name="hashToken" id="hashToken" required>
									</p>
									<input type="button" value="Créer la balise" onclick="createBeacon()">
								</form>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
<div id="info"></div>
<div id="cadre"></div>

<script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC6nZUZlt4bHabhU003YHL1rCpKNGKb974">
</script>
<script async defer>
//		<input type="text" name="themeBeacon" id="themeBeacon" required>

	function TxtOverlay(pos, txt, cls, map) {

      // Now initialize all properties.
      this.pos = pos;
      this.txt_ = txt;
      this.cls_ = cls;
      //this.map_ = map;

      // We define a property to hold the image's
      // div. We'll actually create this div
      // upon receipt of the add() method so we'll
      // leave it null for now.
      this.div_ = null;

      // Explicitly call setMap() on this overlay
      this.setMap(map);
    }

    TxtOverlay.prototype = new google.maps.OverlayView();



    TxtOverlay.prototype.onAdd = function() {

      // Note: an overlay's receipt of onAdd() indicates that
      // the map's panes are now available for attaching
      // the overlay to the map via the DOM.

      // Create the DIV and set some basic attributes.
      let div = document.createElement('DIV');
      div.className = this.cls_;

      div.innerHTML = this.txt_;

      // Set the overlay's div_ property to this DIV
      this.div_ = div;
      let overlayProjection = this.getProjection();
      let position = overlayProjection.fromLatLngToDivPixel(this.pos);
      div.style.left = position.x + 'px';
      div.style.top = position.y + 'px';
      // We add an overlay to a map via one of the map's panes.

      let panes = this.getPanes();
      panes.floatPane.appendChild(div);
    };
    TxtOverlay.prototype.draw = function() {


        let overlayProjection = this.getProjection();

        // Retrieve the southwest and northeast coordinates of this overlay
        // in latlngs and convert them to pixels coordinates.
        // We'll use these coordinates to resize the DIV.
        let position = overlayProjection.fromLatLngToDivPixel(this.pos);


        let div = this.div_;
        div.style.left = position.x + 'px';
        div.style.top = position.y + 'px';



      };

	  
	  
    let geocoder;
    let map;
	const sectors = [];
    let jsonObject = {};
	let pointClick = [];
	let lastSectorClicked;
	let zoneNumber = 0;
	let beaconNumber = 0;
	let modifState = -1;

    function initialize() {
        geocoder = new google.maps.Geocoder();
        const latlng = new google.maps.LatLng(45.75, 4.85);
        const mapOptions = {
            zoom: 12,
            center: latlng
        };
        map = new google.maps.Map(document.getElementById('map'), mapOptions);

    }

    function printJSON() {
        document.getElementById('info').innerHTML += jsonObject.zones[0].name;
		document.getElementById('cadre').innerHTML += JSON.stringify(jsonObject);

    }

    function download() {
        let filename = "map.json";
        let type = "json";
        let file = new Blob([JSON.stringify(jsonObject)], {type: type});
        if (window.navigator.msSaveOrOpenBlob) // IE10+
            window.navigator.msSaveOrOpenBlob(file, filename);
        else { // Others
            let a = document.createElement("a"),
                url = URL.createObjectURL(file);
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(function() {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }
    }

    function lockSectorsInZone(i, j) {
        let sectorX = Math.floor(jsonObject.zones[i].sectors[j]/jsonObject.sector.nbPerLine);
        let sectorY = jsonObject.zones[i].sectors[j] % jsonObject.sector.nbPerLine;

        sectors[sectorX][sectorY].setOptions({
            fillColor: '#0000FF'
        });
        sectors[sectorX][sectorY].selected = 2;
    }

    // Fonction de lecture d'un fichier
    document.querySelector('#file').addEventListener('change', function() {

        let reader = new FileReader();
        beaconNumber = 0;
        reader.addEventListener('load', function() {
            let jsonToParse = reader.result;
            jsonObject = JSON.parse(jsonToParse);

            for(let i = 0; i < jsonObject.zones.length; i++) {
                for (let j = 0; j < jsonObject.zones[i].sectors.length; j++) {
                    lockSectorsInZone(i, j);
                }
                for (let j = 0; j < jsonObject.zones[i].beacons.length; j++) {
                    if (jsonObject.zones[i].beacons[j].id > beaconNumber) {
                        beaconNumber = jsonObject.zones[i].beacons[j].id
                    }
                }
            }
            zoneNumber = jsonObject.zones.length;
            beaconNumber++;

        });

        reader.readAsText(document.querySelector('#file').files[0], 'UTF-8');
    });

	function createZone() {
	    let index = zoneNumber;
	    if(modifState > -1)
        {
            index = modifState;
        }

        if (typeof jsonObject.zones[index] === 'undefined')
        {
            jsonObject.zones[index] = {};
        }

        jsonObject.zones[index].name = document.getElementById('nameZone').value;
        jsonObject.zones[index].description = document.getElementById('descriptionZone').value;

        jsonObject.zones[index].sectors = [];

		for(let i= 0; i < pointClick.length ; i++){
			jsonObject.zones[index].sectors.push(pointClick[i].id);
		}

        if (!jsonObject.zones[index].hasOwnProperty("beacons")) {
            jsonObject.zones[index].beacons = [];
        }

        pointClick.length = 0;

		document.getElementById('nameZone').value = "";
		document.getElementById('descriptionZone').value = "";

        for(let i = 0; i < jsonObject.zones[index].sectors.length; i++)
        {
            lockSectorsInZone(index, i);
        }

        if (modifState > -1)
        {
            modifState = -1;
        }
        document.getElementById('createZoneButton').value = "Créer zone";

    }

	function createBeacon(){
        let zoneFounded = false;
        let i = -1;
        if (!lastSectorClicked)
        {
            return alert("Vous n'avez cliqué sur aucun secteur pour l'instant")
        }
        else {
            while (!zoneFounded && i < jsonObject.zones.length - 1) {
                i++;
                zoneFounded = jsonObject.zones[i].sectors.includes(lastSectorClicked.id);

            }

            if (zoneFounded) {
                jsonObject.zones[i].beacons.push({});
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].id = beaconNumber;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].hash = document.getElementById('hashToken').value;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].difficulty = document.getElementById('difficulty').value;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].theme = document.getElementById('themeBeacon').value;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].name = document.getElementById('nameBeacon').value;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].description = document.getElementById('descriptionBeacon').value;
                jsonObject.zones[i].beacons[jsonObject.zones[i].beacons.length - 1].monumentDesc = document.getElementById('descriptionMonument').value;
                beaconNumber++;
                alert("La balise a été créée avec succès");
            }
            else    // Le dernier secteur cliqué n'appartient à aucune zone déjà existante
            {
                return alert("Le secteur sélectionné en dernier n'appartient à aucune zone !");
            }
        }
        document.getElementById('themeBeacon').value = "SP";
        document.getElementById('nameBeacon').value = "";
        document.getElementById('descriptionBeacon').value = "";
        document.getElementById('descriptionMonument').value = "";
        document.getElementById('hashToken').value = "";
	}

    function codeAddress() {

        for (const x of sectors) {
            for (const y of sectors[x]) {
                if (sectors[x][y].setMap) {
                    sectors[x][y].setMap(null);
                    sectors[x][y] = null;
                }
            }
        }

        const spaceOffset = 0.005;
        const address = document.getElementById('address').value;

        geocoder.geocode({'address': address}, function (results, status) {
            if (status !== google.maps.GeocoderStatus.OK) {
                return alert('Geocode was not successful for the following reason: ' + status);
            }

            const bounds = results[0].geometry.bounds;
            map.setCenter(results[0].geometry.location);

            const marker1 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getNorthEast().lat() + spaceOffset, bounds.getNorthEast().lng() + spaceOffset),
                map: null,
                draggable: false,
                title: 'haut_droite'
            });

            const marker2 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getSouthWest().lat() - spaceOffset, bounds.getSouthWest().lng() - spaceOffset),
                map: null,
                draggable: false,
                title: 'bas_gauche'
            });

            const marker3 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getNorthEast().lat() + spaceOffset, bounds.getSouthWest().lng() - spaceOffset),
                map: map,
                draggable: false,
                title: 'haut_gauche'
            });

            document.getElementById('info').innerHTML += results[0].geometry.bounds.toString() + '</br>';

            const excLat = 0.2;
            const excLng = 0.2;

            const m1Lng = marker1.getPosition().lng();
            const m2Lat = marker2.getPosition().lat();
            const m3Lat = marker3.getPosition().lat();
            const m3Lng = marker3.getPosition().lng();
            const r_earth = 6378;

            let i = 0;
            let j = 0;
			let comptId = 0;
            let newLat = m3Lat;
            let newLng = m3Lng;
			let prevLat = newLat;
			const sectorsId = [];


            while (newLat > m2Lat) {
                if (!sectors[i]) sectors[i] = [];
                j = 0;
                newLat = m3Lat - (i + 1) * (excLat / r_earth) * (180 / Math.PI);
                newLng = m3Lng + ((j + 1) * (excLng / r_earth) * (180 / Math.PI) / Math.cos(m3Lat * Math.PI / 180));
                while (newLng < m1Lng) {
                    if (!sectors[i][j]) sectors[i][j] = {};
					prevLat = newLat;

                    newLat = m3Lat - (i + 1) * (excLat / r_earth) * (180 / Math.PI);
                    newLng = m3Lng + ((j + 1) * (excLng / r_earth) * (180 / Math.PI) / Math.cos(m3Lat * Math.PI / 180));
                    sectors[i][j] = new google.maps.Rectangle({
                        strokeColor: '#FFFFFF',
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.3,
                        map: map,
                        bounds: new google.maps.LatLngBounds(
                            new google.maps.LatLng(m3Lat - (i * (excLat / r_earth) * (180 / Math.PI)), m3Lng + (j * (excLng / r_earth) * (180 / Math.PI) / Math.cos(newLat * Math.PI / 180))),
                            new google.maps.LatLng(newLat, newLng))
                    });
					sectors[i][j].id = comptId;
                    sectors[i][j].selected = 0;

                    google.maps.event.addListener(sectors[i][j], 'click', function () {
                        let doubleClicked = lastSectorClicked === this;
                        lastSectorClicked = this;
                        if (this.selected === 0){
							this.setOptions({
								fillColor: '#00FF00'
							});
							pointClick.push(this);
							document.getElementById('cadre').innerHTML +="Rectangle : " + pointClick[pointClick.indexOf(this)].id + '</br>';
							document.getElementById('info').innerHTML += "id = " + this.id + '</br>';
							this.selected = 1;
                        }
						else if (this.selected === 1){
							this.setOptions({
								fillColor: '#FF0000'
							});
                            let sectorIndex = pointClick.indexOf(this);
                            if (sectorIndex > -1)
                            {
                                pointClick.splice(sectorIndex, 1);
                            }
							this.selected = 0;
						}
						else if (this.selected === 2 && pointClick.length === 0 && doubleClicked)
                        {
                            document.getElementById('createZoneButton').value = "Modifier zone";
                            let zoneIndex = -1;
                            for (let k = 0 ; k < jsonObject.zones.length ; k++)
                            {
                                if (jsonObject.zones[k].sectors.includes(lastSectorClicked.id))
                                {
                                    zoneIndex = k;
                                }
                            }
                            document.getElementById('nameZone').value = jsonObject.zones[zoneIndex].name;
                            document.getElementById('descriptionZone').value = jsonObject.zones[zoneIndex].description;

                            for (let l = 0 ; l < jsonObject.zones[zoneIndex].sectors.length ; l++)
                            {
                                let sectorX = Math.floor(jsonObject.zones[zoneIndex].sectors[l]/jsonObject.sector.nbPerLine);
                                let sectorY = jsonObject.zones[zoneIndex].sectors[l] % jsonObject.sector.nbPerLine;

                                sectors[sectorX][sectorY].setOptions({
                                    fillColor: '#00FF00'
                                });
                                sectors[sectorX][sectorY].selected = 1;

                                pointClick.push(sectors[sectorX][sectorY]);
                            }
                            modifState = zoneIndex;
                            doubleClicked = false;
                            return alert("ATTENTION : Supprimer un ou plusieurs secteurs de la zone n'entraînera pas la suppression des balises existantes sur ce(s) secteur(s) de la zone en question !");
                        }

					});
					
					sectorsId[comptId] = new TxtOverlay(new google.maps.LatLng(m3Lat - (i)*(excLat / r_earth) * (180 / Math.PI), m3Lng + (j*(excLng / r_earth) * (180 / Math.PI) / Math.cos(prevLat * Math.PI/180))), 
						"<div>" + comptId + "</div>", 
						"customBox", 
						map);
                    j++;
					comptId++;
                } //for j Lng
                i++;
            } //for i Lat

            jsonObject.sector = {};
            jsonObject.sector.size = excLat*1000;
            jsonObject.sector.nbPerLine = j;
            jsonObject.sector.origin = {};
            jsonObject.sector.origin.lng = m3Lng;
            jsonObject.sector.origin.lat = m3Lat;
            jsonObject.zones = [];
        });
    }
</script>
</body>
</html>
