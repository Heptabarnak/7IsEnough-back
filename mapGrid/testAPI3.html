<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Premiers tests de l'api</title>
</head>
<body onload="initialize()">
<div id="map" style="width: 520px; height: 480px;"></div>

</div>
<div>
    <input id="address" type="textbox" value="Lyon">
    <input type="button" value="Encode" onclick="codeAddress()">
</div>
<div id="info"></div>
<div id="cadre">
<script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC6nZUZlt4bHabhU003YHL1rCpKNGKb974">
</script>
<script async defer>

	function TxtOverlay(pos, txt, cls, map) {

      // Now initialize all properties.
      this.pos = pos;
      this.txt_ = txt;
      this.cls_ = cls;
      this.map_ = map;

      // We define a property to hold the image's
      // div. We'll actually create this div
      // upon receipt of the add() method so we'll
      // leave it null for now.
      this.div_ = null;

      // Explicitly call setMap() on this overlay
      this.setMap(map);
    }

    TxtOverlay.prototype = new google.maps.OverlayView();



    TxtOverlay.prototype.onAdd = function() {

      // Note: an overlay's receipt of onAdd() indicates that
      // the map's panes are now available for attaching
      // the overlay to the map via the DOM.

      // Create the DIV and set some basic attributes.
      var div = document.createElement('DIV');
      div.className = this.cls_;

      div.innerHTML = this.txt_;

      // Set the overlay's div_ property to this DIV
      this.div_ = div;
      var overlayProjection = this.getProjection();
      var position = overlayProjection.fromLatLngToDivPixel(this.pos);
      div.style.left = position.x + 'px';
      div.style.top = position.y + 'px';
      // We add an overlay to a map via one of the map's panes.

      var panes = this.getPanes();
      panes.floatPane.appendChild(div);
    }
    TxtOverlay.prototype.draw = function() {


        var overlayProjection = this.getProjection();

        // Retrieve the southwest and northeast coordinates of this overlay
        // in latlngs and convert them to pixels coordinates.
        // We'll use these coordinates to resize the DIV.
        var position = overlayProjection.fromLatLngToDivPixel(this.pos);


        var div = this.div_;
        div.style.left = position.x + 'px';
        div.style.top = position.y + 'px';



      }

	  
	  
    let geocoder;
    let map;

    function initialize() {
        geocoder = new google.maps.Geocoder();
        const latlng = new google.maps.LatLng(45.75, 4.85);
        const mapOptions = {
            zoom: 8,
            center: latlng
        };
        map = new google.maps.Map(document.getElementById('map'), mapOptions);

    }

    function codeAddress() {
        const rectangleLat = [];
        const rectangleLng = [];

        for (const x of rectangleLng) {
            for (const y of rectangleLng[x]) {
                if (rectangleLng[x][y].setMap) {
                    rectangleLng[x][y].setMap(null);
                    rectangleLng[x][y] = null;
                }
            }
        }

        const spaceOffset = 0.005;
        const address = document.getElementById('address').value;

        geocoder.geocode({'address': address}, function (results, status) {
            if (status !== google.maps.GeocoderStatus.OK) {
                return alert('Geocode was not successful for the following reason: ' + status);
            }

            const bounds = results[0].geometry.bounds;
            map.setCenter(results[0].geometry.location);

            const marker1 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getNorthEast().lat() + spaceOffset, bounds.getNorthEast().lng() + spaceOffset),
                map: null,
                draggable: false,
                title: 'haut_droite'
            });

            const marker2 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getSouthWest().lat() - spaceOffset, bounds.getSouthWest().lng() - spaceOffset),
                map: null,
                draggable: false,
                title: 'bas_gauche'
            });

            const marker3 = new google.maps.Marker({
                position: new google.maps.LatLng(bounds.getNorthEast().lat() + spaceOffset, bounds.getSouthWest().lng() - spaceOffset),
                map: map,
                draggable: false,
                title: 'haut_gauche'
            });

            document.getElementById('info').innerHTML += results[0].geometry.bounds.toString() + '</br>';

            const excLat = 0.2;
            const excLng = 0.2;

            const m1Lng = marker1.getPosition().lng();
            const m2Lat = marker2.getPosition().lat();
            const m3Lat = marker3.getPosition().lat();
            const m3Lng = marker3.getPosition().lng();
            const r_earth = 6378;
			
			let pointClick = new Array();
            let i = 0;
            let j = 0;
			let comptId = 0;
            let newLat = m3Lat;
            let newLng = m3Lng;
			let prevLat = newLat;
			const sectorsId = [];

            while (newLat > m2Lat) {
                if (!rectangleLng[i]) rectangleLng[i] = [];
                j = 0;
                newLat = m3Lat - (i + 1) * (excLat / r_earth) * (180 / Math.PI);
                newLng = m3Lng + ((j + 1) * (excLng / r_earth) * (180 / Math.PI) / Math.cos(m3Lat * Math.PI / 180));
                while (newLng < m1Lng) {
                    if (!rectangleLng[i][j]) rectangleLng[i][j] = {};
					prevLat = newLat;

                    newLat = m3Lat - (i + 1) * (excLat / r_earth) * (180 / Math.PI);
                    newLng = m3Lng + ((j + 1) * (excLng / r_earth) * (180 / Math.PI) / Math.cos(m3Lat * Math.PI / 180));
                    rectangleLng[i][j] = new google.maps.Rectangle({
                        strokeColor: '#FFFFFF',
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.1,
                        map: map,
                        bounds: new google.maps.LatLngBounds(
                            new google.maps.LatLng(m3Lat - (i * (excLat / r_earth) * (180 / Math.PI)), m3Lng + (j * (excLng / r_earth) * (180 / Math.PI) / Math.cos(newLat * Math.PI / 180))),
                            new google.maps.LatLng(newLat, newLng))
                    });
					rectangleLng[i][j].id = comptId;
                    rectangleLng[i][j].selected = false;

                    google.maps.event.addListener(rectangleLng[i][j], 'click', function () {
                        if (!this.selected){
							this.setOptions({
								fillColor: '#00FF00'
							});
							pointClick.push(this);
							document.getElementById('cadre').innerHTML +="Rectangle : " + pointClick[pointClick.indexOf(this)].getBounds() + '</br>';
							document.getElementById('info').innerHTML += "id = " + this.id + '</br>';
                        }
						else {
							this.setOptions({
								fillColor: '#FF0000'
							});
						}
						this.selected = !this.selected;
					
					});
					
					sectorsId[comptId] = new TxtOverlay(new google.maps.LatLng(m3Lat - (i)*(excLat / r_earth) * (180 / Math.PI), m3Lng + (j*(excLng / r_earth) * (180 / Math.PI) / Math.cos(prevLat * Math.PI/180))), 
						"<div>" + comptId + "</div>", 
						"customBox", 
						map);
                    j++;
					comptId++;
                } //for j Lng
                i++;
            } //for i Lat
        });
    }
</script>
</body>
</html>
